1.mysql 

innodb： 
1.查询走的索引，则锁为行级锁
2.查询没有走索引，则锁为表锁

行级锁是针对索引加的锁，如果访问的是不同的数据，但使用的相同的索引建，也会发生锁等待

如：select * from tab where id = 1
select * from tab where id= 1 and name = '2'

不同的索引 查询相同的记录时，也会发生锁等待。针对索引加锁，具体的数据会被锁定。
相同的索引或不同的索引查询不同的记录，没有问题。



1.select * from  读数据库快照，不加锁

2.select * from lock in share mode 加共享锁

3.select * from for update 加排他锁


死锁产生的原因：
1.如果两个是事务A，B查询同一条数据加共享锁，
事务A接着更新数据，此时，共享锁升级为排它锁，需要等待事务B释放共享锁
事务B也要更新数据，此时发生死锁。

2.事务A 使用select for update 对数据a加排它锁，
更新数据

事务B使用select for update 对数据b加排它锁，
更新数据，
此时事务A 准备更新数据b
事务B准备更新数据a

发生死锁。




间隙锁：
当我们使用范围条件而不是相等条件检索数据，并请求共享锁或者排它锁，InnoDB会对符合条件的已有记录的索引项加锁。但对于键值在条件范围内，但不存在的记录
叫做间隙， InnoDB也会对这个间隙加锁，这种锁机制就是所谓的间隙锁。
举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,...,100,101，下面的SQL：
Select * from  emp where empid > 100 for update;
是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。
InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，
如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。
有关其恢复和复制对锁机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况

还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！








