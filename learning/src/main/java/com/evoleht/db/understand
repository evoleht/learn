1.mysql 

数据库事务隔离级别有
1.读未提交 read un commit
2.读提交 read commit
3.重复读 read repeat
4.串行读
mysql 默认的隔离级别是 read repeat。

innodb： 
1.查询走的索引，则锁为行级锁
2.查询没有走索引，则锁为表锁

行级锁是针对索引加的锁，如果访问的是不同的数据，但使用的相同的索引建，也会发生锁等待

如：select * from tab where id = 1
select * from tab where id= 1 and name = '2'

不同的索引 查询相同的记录时，也会发生锁等待。针对索引加锁，具体的数据会被锁定。
相同的索引或不同的索引查询不同的记录，没有问题。



1.select * from  读数据库快照，不加锁

2.select * from lock in share mode 加共享锁

3.select * from for update 加排他锁

一致性非锁定读是指InnoDB存储引擎通过多版本控制的方式来读取当前执行时间的数据库中行的数据。如果读取的行正在执行update
或delete 操作，读取操作不会等待行上的锁释放。InnoDB读取的是一个数据快照。

在事务隔离级别RC和RR下，InnoDB默认的是一致性非锁定读。但是这两种对快照数据的定义不同。在rc级别下，对应快照数据，
非锁定读都是最新的一份数据快照。
而在RR级别下，对应的数据快照，总是事务开启时的数据快照。

一致性读会存在幻读问题：
RR级别，一致性读的都是当前事务开启之前数据库已经提交了事务的数据快照，在此事务之间，所有的读操作都是第一条select读取
的数据快照，当此时其他事务进行了数据的更新或插入操作，并提交了事务，此时修改或新增、删除的数据对于当前事务的select是不可见的，
当当前事务执行了update、insert、delete
操作时，其他事务的操作会被此事务的select查询到，由此出现了幻读





死锁产生的原因：
1.如果两个是事务A，B查询同一条数据加共享锁，
事务A接着更新数据，此时，共享锁升级为排它锁，需要等待事务B释放共享锁
事务B也要更新数据，此时发生死锁。

2.事务A 使用select for update 对数据a加排它锁，
更新数据

事务B使用select for update 对数据b加排它锁，
更新数据，
此时事务A 准备更新数据b
事务B准备更新数据a

发生死锁。




间隙锁：
当我们使用范围条件而不是相等条件检索数据，并请求共享锁或者排它锁，InnoDB会对符合条件的已有记录的索引项加锁。但对于键值在条件范围内，但不存在的记录
叫做间隙， InnoDB也会对这个间隙加锁，这种锁机制就是所谓的间隙锁。
举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,...,100,101，下面的SQL：
Select * from  emp where empid > 100 for update;
是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。
InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，
如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。
有关其恢复和复制对锁机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况

还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！



	





