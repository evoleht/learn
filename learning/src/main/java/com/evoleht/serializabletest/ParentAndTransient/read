
1.Transient 关键字可以使字段不会被序列化

2.一个子类实现了Serializable接口，他的父类都没有实现Serializable接口，序列化该子类的对象，然后反序列化输出父类定义的某变量的数值，
该变量的值与序列化时的值不同。

解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就 需要有默认的无参的构造函数。
在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，
只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。
如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。


针对这种情况使用情景：

根据父类的序列化的规则，可以将不需要序列化的字段抽取出来放到父类中，子类实现Serializable接口，父类不实现，根据父类的序列化规则，父类的字段数据将不会被序列化。

好处就是多个子类不需要重写Transient，代码简洁；


3.敏感字段加密解密

情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，
只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。

解决：在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，
则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。
用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，
比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作.
示例：UserDefinedTest.java


4.序列化存储规则

Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，
并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。
反序列化时，恢复引用关系，使得清单 StorageTest.java methodA中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。

methodB 的目的是希望将 StorageTest 对象两次保存到 result.obj 文件中，写入一次以后修改对象属性值再次保存第二次，
然后从 result.obj 中再依次读出两个对象，输出这两个对象的 name 属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。

结果两个输出的都是 "li"， 原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，
因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。
在使用一个文件多次 writeObject 需要特别注意这个问题。




















